{
  "name": "TNER - Auto-Fix Reconciliation Errors",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.xero.com/connections",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "xeroOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "get-connections",
      "name": "Get Xero Organizations",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        460,
        300
      ],
      "credentials": {
        "xeroOAuth2Api": {
          "id": "REDACTED",
          "name": "Xero account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const connections = $input.all();\nconst alwcConnection = connections.find(conn => conn.json.tenantName && conn.json.tenantName.toUpperCase().includes('ALWC'));\nif (!alwcConnection) { throw new Error('ALWC not found'); }\nreturn [{ json: { tenantId: alwcConnection.json.tenantId } }];"
      },
      "id": "find-alwc",
      "name": "Find ALWC",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.xero.com/api.xro/2.0/BankTransactions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "xeroOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "xero-tenant-id",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "get-recent",
      "name": "Get Recent Transactions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        900,
        300
      ],
      "credentials": {
        "xeroOAuth2Api": {
          "id": "REDACTED",
          "name": "Xero account"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://mgldctmrbajwqcwqywjj.supabase.co/rest/v1/vendor_categorization_patterns?company=eq.TNER&select=*",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_ANON_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "get-learned-patterns",
      "name": "Get Learned Patterns",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        900,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get data from previous nodes\nconst transactions = $('Get Recent Transactions').first().json.BankTransactions || [];\nconst learnedPatterns = $input.first().json || [];\nconst tenantId = $('Find ALWC').item.json.tenantId;\n\n// Build vendor pattern lookup from Supabase\nconst vendorPatterns = {};\nfor (const pattern of learnedPatterns) {\n  const key = pattern.vendor_name_normalized;\n  if (!vendorPatterns[key]) {\n    vendorPatterns[key] = [];\n  }\n  vendorPatterns[key].push({\n    accountCode: pattern.account_code,\n    taxType: pattern.tax_type,\n    occurrences: pattern.occurrences,\n    confidenceLevel: pattern.confidence_level,\n    confidenceScore: pattern.confidence_score\n  });\n}\n\n// Fallback rules (when no learned patterns exist)\nconst fallbackRules = {\n  correctTaxType: 'NONE',\n  wrongTaxCodes: ['OUTPUT2', 'INPUT2', 'OUTPUTY24', 'INPUTY24'],\n  patterns: {\n    'bank fee': '404',\n    'bank charge': '404',\n    'service fee': '404',\n    'transaction fee': '404'\n  }\n};\n\n// Filter to last 10 minutes with LineItems\nconst tenMinsAgo = new Date(Date.now() - 10 * 60 * 1000);\nconst recentTxns = transactions.filter(txn => {\n  const updated = new Date(txn.UpdatedDateUTC);\n  return updated >= tenMinsAgo && txn.LineItems && txn.LineItems.length > 0;\n});\n\nconsole.log(`Checking ${recentTxns.length} recent transactions against ${Object.keys(vendorPatterns).length} learned vendor patterns`);\n\nconst corrections = [];\nconst checkedOK = [];\n\nfor (const txn of recentTxns) {\n  const contact = txn.Contact?.Name || '';\n  const reference = txn.Reference || '';\n  const lineItem = txn.LineItems[0];\n  const description = (lineItem?.Description || '').toLowerCase();\n  const accountCode = lineItem?.AccountCode || '';\n  const taxType = lineItem?.TaxType || '';\n  const amount = txn.Total;\n  \n  const vendorName = contact || reference.split(' ')[0] || '';\n  const vendorKey = vendorName.toLowerCase().trim();\n  \n  let needsCorrection = false;\n  let suggestedAccount = accountCode;\n  let suggestedTax = taxType;\n  let reason = [];\n  let confidenceLevel = 'UNKNOWN';\n  \n  // Check 1: Learned vendor patterns (HIGHEST PRIORITY)\n  if (vendorKey && vendorPatterns[vendorKey]) {\n    const patterns = vendorPatterns[vendorKey];\n    // Use most common pattern (highest occurrences)\n    const bestPattern = patterns.sort((a, b) => b.occurrences - a.occurrences)[0];\n    \n    if (bestPattern.accountCode !== accountCode) {\n      // Only flag/fix if confidence is HIGH or VERY_HIGH\n      if (bestPattern.confidenceLevel === 'HIGH' || bestPattern.confidenceLevel === 'VERY_HIGH') {\n        needsCorrection = true;\n        suggestedAccount = bestPattern.accountCode;\n        reason.push(`Learned: \"${vendorName}\" usually coded to ${bestPattern.accountCode} (${bestPattern.occurrences}x, ${bestPattern.confidenceLevel} confidence)`);\n        confidenceLevel = bestPattern.confidenceLevel;\n      }\n    }\n    \n    if (bestPattern.taxType !== taxType) {\n      if (bestPattern.confidenceLevel === 'HIGH' || bestPattern.confidenceLevel === 'VERY_HIGH') {\n        needsCorrection = true;\n        suggestedTax = bestPattern.taxType;\n        reason.push(`Learned: \"${vendorName}\" usually has ${bestPattern.taxType} tax`);\n      }\n    }\n  }\n  \n  // Check 2: Tax code validation (CRITICAL - always enforce)\n  if (fallbackRules.wrongTaxCodes.includes(taxType)) {\n    needsCorrection = true;\n    suggestedTax = fallbackRules.correctTaxType;\n    reason.push(`Tax should be No Tax (0%), not ${taxType} - TNER not GST registered`);\n    confidenceLevel = 'CRITICAL';\n  }\n  \n  // Check 3: Keyword fallback patterns (only if no learned pattern)\n  if (!vendorPatterns[vendorKey]) {\n    for (const [pattern, code] of Object.entries(fallbackRules.patterns)) {\n      if (description.includes(pattern) && accountCode !== code) {\n        needsCorrection = true;\n        suggestedAccount = code;\n        reason.push(`Keyword match: \"${pattern}\" suggests ${code}`);\n        confidenceLevel = 'MEDIUM';\n      }\n    }\n  }\n  \n  if (needsCorrection) {\n    corrections.push({\n      BankTransactionID: txn.BankTransactionID,\n      Date: txn.Date,\n      Contact: txn.Contact,\n      Reference: reference,\n      Total: amount,\n      Type: txn.Type,\n      BankAccount: txn.BankAccount,\n      currentAccountCode: accountCode,\n      currentTaxType: taxType,\n      suggestedAccountCode: suggestedAccount,\n      suggestedTaxType: suggestedTax,\n      description: lineItem?.Description,\n      reason: reason.join('; '),\n      confidenceLevel: confidenceLevel,\n      tenantId: tenantId,\n      LineItems: [{\n        Description: lineItem?.Description,\n        Quantity: lineItem?.Quantity || 1,\n        UnitAmount: lineItem?.UnitAmount || amount,\n        AccountCode: suggestedAccount,\n        TaxType: suggestedTax,\n        LineAmount: lineItem?.LineAmount || amount\n      }]\n    });\n  } else {\n    checkedOK.push({\n      contact: vendorName,\n      amount: amount,\n      accountCode: accountCode,\n      taxType: taxType\n    });\n  }\n}\n\nconsole.log(`Corrections needed: ${corrections.length}`);\nconsole.log(`Already correct: ${checkedOK.length}`);\n\nreturn [{\n  json: {\n    hasErrors: corrections.length > 0,\n    errorsFound: corrections.length,\n    correctCount: checkedOK.length,\n    totalChecked: recentTxns.length,\n    learnedPatternsCount: Object.keys(vendorPatterns).length,\n    corrections: corrections,\n    checkedOK: checkedOK,\n    tenantId: tenantId\n  }\n}];"
      },
      "id": "detect-errors",
      "name": "Detect Categorization Errors",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        380
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-errors",
              "leftValue": "={{ $json.hasErrors }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check-errors",
      "name": "Has Errors?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1340,
        380
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst corrections = data.corrections || [];\nreturn corrections.map(c => ({ json: c }));"
      },
      "id": "split-corrections",
      "name": "Split Corrections",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.xero.com/api.xro/2.0/BankTransactions/{{ $json.BankTransactionID }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "xeroOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "xero-tenant-id",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"Type\": $json.Type,\n  \"Contact\": $json.Contact,\n  \"LineItems\": $json.LineItems,\n  \"BankAccount\": $json.BankAccount\n} }}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 1000
            }
          }
        }
      },
      "id": "fix-transaction",
      "name": "Auto-Fix Transaction",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1780,
        300
      ],
      "credentials": {
        "xeroOAuth2Api": {
          "id": "REDACTED",
          "name": "Xero account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const results = $input.all();\nconst criticalCount = results.filter(r => r.json.confidenceLevel === 'CRITICAL').length;\nconst highCount = results.filter(r => r.json.confidenceLevel === 'VERY_HIGH' || r.json.confidenceLevel === 'HIGH').length;\n\nconst summary = `âœ… *TNER Auto-Fix Complete*\\n${new Date().toLocaleString()}\\n\\nðŸ”§ Fixed ${results.length} transaction(s):\\n${criticalCount > 0 ? `âš ï¸ ${criticalCount} critical, ` : ''}${highCount > 0 ? `ðŸŸ  ${highCount} high confidence` : ''}\\n\\n${results.slice(0, 5).map((r, i) => {\n  const txn = r.json;\n  const icon = txn.confidenceLevel === 'CRITICAL' ? 'âš ï¸' : txn.confidenceLevel === 'VERY_HIGH' ? 'ðŸ”´' : 'ðŸŸ ';\n  return `${icon} ${i+1}. ${txn.Contact?.Name || txn.Reference} - $${txn.Total}\\n   From: ${txn.currentAccountCode} (${txn.currentTaxType})\\n   To: ${txn.suggestedAccountCode} (${txn.suggestedTaxType})\\n   ${txn.reason}`;\n}).join('\\n\\n')}${results.length > 5 ? `\\n\\n...and ${results.length - 5} more` : ''}`;\n\nconsole.log(summary);\nreturn [{ json: { summary, fixedCount: results.length } }];"
      },
      "id": "summary-fixed",
      "name": "Summary - Fixed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst summary = `âœ… *TNER Reconciliation Check*\\n${new Date().toLocaleString()}\\n\\nðŸ“Š Checked ${data.totalChecked} recent transaction(s)\\nðŸ§  Using ${data.learnedPatternsCount} learned vendor pattern(s)\\n\\nâœ… All correctly categorized!\\n${data.checkedOK.length > 0 && data.checkedOK.length <= 5 ? '\\n' + data.checkedOK.map(t => `â€¢ ${t.contact} - $${t.amount} â†’ ${t.accountCode}`).join('\\n') : ''}\\n\\nðŸŽ‰ No corrections needed!`;\n\nconsole.log(summary);\nreturn [{ json: { summary, checkedCount: data.totalChecked, learnedPatternsCount: data.learnedPatternsCount } }];"
      },
      "id": "summary-ok",
      "name": "Summary - All OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        460
      ]
    }
  ],
  "connections": {
    "Every 5 Minutes": {
      "main": [
        [
          {
            "node": "Get Xero Organizations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Xero Organizations": {
      "main": [
        [
          {
            "node": "Find ALWC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find ALWC": {
      "main": [
        [
          {
            "node": "Get Recent Transactions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Learned Patterns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Recent Transactions": {
      "main": [
        [
          {
            "node": "Detect Categorization Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Learned Patterns": {
      "main": [
        [
          {
            "node": "Detect Categorization Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Categorization Errors": {
      "main": [
        [
          {
            "node": "Has Errors?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Errors?": {
      "main": [
        [
          {
            "node": "Split Corrections",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Summary - All OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Corrections": {
      "main": [
        [
          {
            "node": "Auto-Fix Transaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto-Fix Transaction": {
      "main": [
        [
          {
            "node": "Summary - Fixed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summary - All OK": {
      "main": [
        []
      ]
    }
  },
  "settings": {
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "executionTimeout": 3600,
    "timezone": "UTC"
  },
  "staticData": null,
  "meta": {
    "exportedAt": "2025-12-06T05:32:08.847Z",
    "n8nId": "CtQrV5tpgg3RlP2v",
    "active": false,
    "note": "Credentials and secrets have been redacted. Re-configure in n8n after import."
  }
}