{
  "name": "TNER - Sync Invoices to Calendar",
  "nodes": [
    {
      "parameters": {},
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        250,
        200
      ],
      "id": "manual-trigger-test"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "name": "Schedule (Hourly)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        250,
        400
      ],
      "id": "schedule"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.xero.com/connections",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "xeroOAuth2Api"
      },
      "name": "Get Orgs",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        450,
        300
      ],
      "credentials": {
        "xeroOAuth2Api": {
          "id": "REDACTED",
          "name": "Xero account"
        }
      },
      "id": "get-orgs"
    },
    {
      "parameters": {
        "jsCode": "const alwc = $input.all().find(c => c.json.tenantName?.toUpperCase().includes('ALWC'));\nif (!alwc) throw new Error('ALWC not found');\nreturn { tenantId: alwc.json.tenantId };"
      },
      "name": "Find ALWC",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        650,
        300
      ],
      "id": "find-alwc"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.xero.com/api.xro/2.0/Invoices?where=Type==\"ACCREC\"&order=Date DESC",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "xeroOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "xero-tenant-id",
              "value": "={{ $json.tenantId }}"
            }
          ]
        }
      },
      "name": "Get All Invoices",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        850,
        300
      ],
      "credentials": {
        "xeroOAuth2Api": {
          "id": "REDACTED",
          "name": "Xero account"
        }
      },
      "id": "get-invoices"
    },
    {
      "parameters": {
        "jsCode": "const invoices = $input.item.json.Invoices || [];\nconst output = [];\nconst officeAddress = '10 Ubi Crescent #04-17B, Lobby B, Singapore 408564';\n\nconst formatDateSG = (date) => {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n};\n\nconst parseDate = (dateStr) => {\n  const monthMap = {'Jan':0,'Feb':1,'Mar':2,'Apr':3,'May':4,'Jun':5,'Jul':6,'Aug':7,'Sep':8,'Oct':9,'Nov':10,'Dec':11,'January':0,'February':1,'March':2,'April':3,'May':4,'June':5,'July':6,'August':7,'September':8,'October':9,'November':10,'December':11};\n  const match = dateStr.match(/(\\d+)\\s+(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[,\\s]+(\\d{4})/i);\n  if (match) {\n    const day = parseInt(match[1]);\n    const month = monthMap[match[2]];\n    const year = parseInt(match[3]);\n    return new Date(year, month, day);\n  }\n  return null;\n};\n\nfor (const inv of invoices) {\n  if (inv.Status === 'DELETED' || inv.Status === 'VOIDED') continue;\n  \n  const ref = inv.Reference || '';\n  const isSelfCollect = ref.includes('Self Collect');\n  let deliveryDate = null;\n  let collectionDate = null;\n  let customerAddress = officeAddress;\n  let deliveryJobType = 'Delivery';\n  let collectionJobType = 'Collection';\n  \n  let deliveryItem = inv.LineItems?.find(item => item.ItemCode === 'DEL-001');\n  \n  if (deliveryItem) {\n    const desc = deliveryItem.Description || '';\n    const deliveryMatch = desc.match(/Delivery\\s+date[:\\s]+([^\\n]+)/i);\n    if (deliveryMatch) deliveryDate = parseDate(deliveryMatch[1]);\n    const collectionMatch = desc.match(/Collection\\s+date[:\\s]+([^\\n]+)/i);\n    if (collectionMatch) collectionDate = parseDate(collectionMatch[1]);\n    const addressMatch = desc.match(/(?:Delivery|Collection)\\s+(?:&\\s+collection\\s+)?address[:\\s]+([^\\n]+(?:\\n[^\\n]+)?)/i);\n    if (addressMatch) customerAddress = addressMatch[1].replace(/\\n/g, ' ').trim();\n  }\n  \n  if (!deliveryDate || !collectionDate) {\n    const deliveryFeeItem = inv.LineItems?.find(item => item.Description?.includes('Delivery Fee'));\n    const collectionFeeItem = inv.LineItems?.find(item => item.Description?.includes('Collection Fee'));\n    \n    if (deliveryFeeItem) {\n      const desc = deliveryFeeItem.Description || '';\n      const dateMatch = desc.match(/(?:Scheduled|Date)[:\\s]+([^\\n]+)/i);\n      if (dateMatch) deliveryDate = parseDate(dateMatch[1]);\n      const addressMatch = desc.match(/Address[:\\s]+([^\\n]+)/i);\n      if (addressMatch) customerAddress = addressMatch[1].trim();\n      deliveryJobType = 'Delivery';\n    }\n    \n    if (collectionFeeItem) {\n      const desc = collectionFeeItem.Description || '';\n      const dateMatch = desc.match(/(?:Scheduled|Date)[:\\s]+([^\\n]+)/i);\n      if (dateMatch) collectionDate = parseDate(dateMatch[1]);\n      const addressMatch = desc.match(/Address[:\\s]+([^\\n]+)/i);\n      if (addressMatch && customerAddress !== officeAddress) customerAddress = addressMatch[1].trim();\n      collectionJobType = 'Collection';\n    }\n  }\n  \n  if ((!deliveryDate || !collectionDate) && isSelfCollect) {\n    const dateMatch = ref.match(/(\\d+)\\s+(\\w+)\\s*-\\s*(\\d+)\\s+(\\w+)\\s+(\\d+)/);\n    if (dateMatch) {\n      const monthMap = {'Jan':0,'Feb':1,'Mar':2,'Apr':3,'May':4,'Jun':5,'Jul':6,'Aug':7,'Sep':8,'Oct':9,'Nov':10,'Dec':11};\n      const [, day1, month1, day2, month2, year] = dateMatch;\n      if (!deliveryDate) {\n        deliveryDate = new Date(parseInt(year), monthMap[month1], parseInt(day1));\n        deliveryJobType = 'Collection';\n      }\n      if (!collectionDate) {\n        collectionDate = new Date(parseInt(year), monthMap[month2], parseInt(day2));\n        collectionJobType = 'Return';\n      }\n    }\n  }\n  \n  if (!deliveryDate && !collectionDate) continue;\n  \n  const contact = inv.Contact || {};\n  const customerPhone = contact.Phones?.[0]?.PhoneNumber || '+65 (from Xero)';\n  \n  if (customerAddress === officeAddress && !isSelfCollect) {\n    const addresses = contact.Addresses || [];\n    const streetAddr = addresses.find(a => a.AddressType === 'STREET') || addresses[0];\n    if (streetAddr && streetAddr.AddressLine1) {\n      const parts = [streetAddr.AddressLine1, streetAddr.AddressLine2, streetAddr.PostalCode ? 'S'+streetAddr.PostalCode : ''].filter(p => p);\n      customerAddress = parts.join(' ');\n    }\n  }\n  \n  if (deliveryDate) {\n    output.push({\n      invoiceNumber: inv.InvoiceNumber,\n      invoiceId: inv.InvoiceID,\n      customerName: contact.Name,\n      customerAddress: isSelfCollect ? officeAddress : customerAddress,\n      customerPhone: customerPhone,\n      jobDate: formatDateSG(deliveryDate),\n      jobType: deliveryJobType,\n      description: inv.LineItems?.[0]?.Description?.split('\\n')[0] || 'Luggage Rental',\n      total: inv.Total,\n      amountPaid: inv.AmountPaid,\n      status: inv.Status\n    });\n  }\n  \n  if (collectionDate) {\n    output.push({\n      invoiceNumber: inv.InvoiceNumber,\n      invoiceId: inv.InvoiceID,\n      customerName: contact.Name,\n      customerAddress: isSelfCollect ? officeAddress : customerAddress,\n      customerPhone: customerPhone,\n      jobDate: formatDateSG(collectionDate),\n      jobType: collectionJobType,\n      description: inv.LineItems?.[0]?.Description?.split('\\n')[0] || 'Luggage Rental',\n      total: inv.Total,\n      amountPaid: inv.AmountPaid,\n      status: inv.Status\n    });\n  }\n}\n\nreturn output;"
      },
      "name": "Parse Invoices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1050,
        300
      ],
      "id": "parse"
    },
    {
      "parameters": {
        "jsCode": "const job = $input.item.json;\n\nreturn {\n  job_ref: `${job.invoiceNumber}-${job.jobType.toUpperCase()}`,\n  xero_invoice_number: job.invoiceNumber,\n  xero_invoice_id: job.invoiceId,\n  company: 'TNER',\n  customer_name: job.customerName,\n  customer_phone: job.customerPhone,\n  customer_address: job.customerAddress,\n  product_description: job.description,\n  installation_date: job.jobDate,\n  installation_time: 'To be arranged',\n  job_status: 'pending',\n  payment_status: job.status === 'PAID' ? 'paid' : 'unpaid',\n  total_amount: job.total,\n  amount_paid: job.amountPaid,\n  job_type: job.jobType,\n  completed_at: null\n};"
      },
      "name": "Prepare Job Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1250,
        300
      ],
      "id": "prepare"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://cngqenuugtgfkrwagllk.supabase.co/rest/v1/installation_jobs",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "JWT_REDACTED"
            },
            {
              "name": "Authorization",
              "value": "Bearer REDACTED"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}"
      },
      "name": "Insert to Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1450,
        300
      ],
      "id": "insert"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:3000/api/geocode-jobs"
      },
      "name": "Auto-Geocode Addresses",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1650,
        300
      ],
      "id": "geocode"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:3000/api/fix-xero-invoice-ids"
      },
      "name": "Fix Missing Invoice IDs",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1850,
        300
      ],
      "id": "fix-invoice-ids"
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Get Orgs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule (Hourly)": {
      "main": [
        [
          {
            "node": "Get Orgs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Orgs": {
      "main": [
        [
          {
            "node": "Find ALWC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find ALWC": {
      "main": [
        [
          {
            "node": "Get All Invoices",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Invoices": {
      "main": [
        [
          {
            "node": "Parse Invoices",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Invoices": {
      "main": [
        [
          {
            "node": "Prepare Job Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Job Data": {
      "main": [
        [
          {
            "node": "Insert to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert to Supabase": {
      "main": [
        [
          {
            "node": "Auto-Geocode Addresses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto-Geocode Addresses": {
      "main": [
        [
          {
            "node": "Fix Missing Invoice IDs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": {
    "exportedAt": "2025-12-06T05:32:08.852Z",
    "n8nId": "vyiQSLv9QdkVl6va",
    "active": true,
    "note": "Credentials and secrets have been redacted. Re-configure in n8n after import."
  }
}